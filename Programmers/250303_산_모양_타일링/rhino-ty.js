// 처음엔 완전 탐색느낌으로 DFS를 구현하려고 했다가 N의 제한사항 덕분에 다른 방법으로 바꿨음
// DP로 접근해야할 듯, 전체 경우의 수에 대해 탐색 후 DP 저장 및 계산
// 1. 각 위치별로 상태를 두 가지로 나눔
//    - 평평하게 끝난 상태
//    - 위로 튀어나온 상태
// 2. DP 배열 초기값 설정
// 3. i=1부터 n까지 각 위치별로 이전 상태에서 계산
//    - tops[i-1]에 따라 규칙 다르게 적용
//    - 삼각형이 있으면 경우의 수가 더 많아짐
// 4. 각 계산마다 나머지(MOD) 연산 적용
// 5. 마지막 위치에서 두 상태 합쳐서 반환

function solution(n, tops) {
  const MOD = 10007;

  // dp[i][0]: i번째 위치에서 평평하게 끝나는 경우의 수
  // dp[i][1]: i번째 위치에서 위로 튀어나온 상태로 끝나는 경우의 수
  const dp = Array.from({ length: n + 1 }, () => [0, 0]);

  // 초기 상태 설정, 평평한 상태로 시작
  dp[0][0] = 1;

  for (let i = 1; i <= n; i++) {
    // 위에 삼각형이 있는 경우
    if (tops[i - 1] === 1) {
      dp[i][0] = (dp[i - 1][0] * 3 + dp[i - 1][1] * 2) % MOD;
      dp[i][1] = (dp[i - 1][0] * 2 + dp[i - 1][1] * 2) % MOD;
    }
    // 위에 삼각형이 없는 경우
    else {
      dp[i][0] = (dp[i - 1][0] * 2 + dp[i - 1][1] * 1) % MOD;
      dp[i][1] = (dp[i - 1][0] * 1 + dp[i - 1][1] * 1) % MOD;
    }
  }

  // 마지막 위치에서 두 상태의 합 반환
  return (dp[n][0] + dp[n][1]) % MOD;
}
